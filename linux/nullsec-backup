#!/bin/bash
# ============================================================================
# NullSec Backup - Encrypted Backup & Restore System
# ============================================================================
# AES-256 encrypted backups with versioning
# Licensed under NullSec Public License v1.0
# ============================================================================

VERSION="1.0.0"
BACKUP_DIR="$HOME/.local/share/nullsec/backups"
CONFIG_FILE="$HOME/.config/nullsec/backup.conf"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

banner() {
    echo -e "${BLUE}"
    cat << 'EOF'
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘          NULLSEC BACKUP v1.0                                  â•‘
    â•‘          Encrypted Backup System                              â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${NC}"
}

log() { echo -e "${GREEN}[âœ“]${NC} $1"; }
warn() { echo -e "${YELLOW}[!]${NC} $1"; }
error() { echo -e "${RED}[âœ—]${NC} $1"; exit 1; }
info() { echo -e "${BLUE}[i]${NC} $1"; }

init() {
    mkdir -p "$BACKUP_DIR"/{daily,weekly,monthly,manual}
    mkdir -p "$(dirname "$CONFIG_FILE")"
    
    # Default config
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" << 'EOF'
# NullSec Backup Configuration
BACKUP_PATHS="$HOME/Documents $HOME/.config $HOME/.local/bin"
EXCLUDE_PATTERNS="*.tmp *.cache *node_modules* *.git*"
KEEP_DAILY=7
KEEP_WEEKLY=4
KEEP_MONTHLY=6
COMPRESSION="gzip"
ENCRYPT=true
EOF
    fi
    source "$CONFIG_FILE"
}

# Generate encryption key from password
derive_key() {
    local password="$1"
    echo -n "$password" | openssl dgst -sha256 | cut -d' ' -f2
}

# Create encrypted backup
create_backup() {
    local name="${1:-manual}"
    local category="${2:-manual}"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$BACKUP_DIR/$category/nullsec-backup-$name-$timestamp"
    
    # Get password
    if [[ "$ENCRYPT" == "true" ]]; then
        echo -n "Enter backup password: "
        read -rs password
        echo ""
        [[ -z "$password" ]] && error "Password required for encrypted backup"
    fi
    
    info "Creating backup: $name"
    
    # Build exclude arguments
    local exclude_args=""
    for pattern in $EXCLUDE_PATTERNS; do
        exclude_args+="--exclude=$pattern "
    done
    
    # Create tarball
    local paths_to_backup=""
    for path in $BACKUP_PATHS; do
        path=$(eval echo "$path")
        [[ -e "$path" ]] && paths_to_backup+="$path "
    done
    
    if [[ -z "$paths_to_backup" ]]; then
        error "No valid paths to backup"
    fi
    
    info "Backing up: $paths_to_backup"
    
    # Create archive
    tar -czf "$backup_file.tar.gz" $exclude_args $paths_to_backup 2>/dev/null
    
    if [[ "$ENCRYPT" == "true" ]]; then
        info "Encrypting backup..."
        openssl enc -aes-256-cbc -salt -pbkdf2 -iter 100000 \
            -in "$backup_file.tar.gz" \
            -out "$backup_file.tar.gz.enc" \
            -pass "pass:$password"
        rm -f "$backup_file.tar.gz"
        backup_file="$backup_file.tar.gz.enc"
    else
        backup_file="$backup_file.tar.gz"
    fi
    
    # Generate checksum
    sha256sum "$backup_file" > "$backup_file.sha256"
    
    local size=$(du -h "$backup_file" | cut -f1)
    log "Backup created: $backup_file ($size)"
    
    # Cleanup old backups
    cleanup_old_backups "$category"
}

# Restore from backup
restore_backup() {
    local backup_file="$1"
    local restore_dir="${2:-$HOME/nullsec-restore}"
    
    [[ ! -f "$backup_file" ]] && error "Backup file not found: $backup_file"
    
    mkdir -p "$restore_dir"
    
    info "Restoring from: $backup_file"
    info "Restore to: $restore_dir"
    
    local temp_file="$backup_file"
    
    # Decrypt if encrypted
    if [[ "$backup_file" == *.enc ]]; then
        echo -n "Enter backup password: "
        read -rs password
        echo ""
        
        info "Decrypting..."
        temp_file="/tmp/nullsec-restore-$$.tar.gz"
        openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 \
            -in "$backup_file" \
            -out "$temp_file" \
            -pass "pass:$password" || error "Decryption failed"
    fi
    
    # Verify checksum
    if [[ -f "$backup_file.sha256" ]]; then
        info "Verifying checksum..."
        if [[ "$backup_file" == *.enc ]]; then
            sha256sum -c "$backup_file.sha256" --status && log "Checksum valid" || warn "Checksum mismatch"
        fi
    fi
    
    # Extract
    info "Extracting..."
    tar -xzf "$temp_file" -C "$restore_dir"
    
    # Cleanup temp
    [[ "$backup_file" == *.enc ]] && rm -f "$temp_file"
    
    log "Restore complete: $restore_dir"
}

# List backups
list_backups() {
    banner
    info "Available backups:"
    echo ""
    
    for category in daily weekly monthly manual; do
        local dir="$BACKUP_DIR/$category"
        [[ ! -d "$dir" ]] && continue
        
        local count=$(ls "$dir"/*.enc "$dir"/*.gz 2>/dev/null | wc -l)
        [[ $count -eq 0 ]] && continue
        
        echo -e "${CYAN}=== $category ($count) ===${NC}"
        
        for backup in "$dir"/*; do
            [[ ! -f "$backup" ]] && continue
            [[ "$backup" == *.sha256 ]] && continue
            
            local size=$(du -h "$backup" | cut -f1)
            local date=$(stat -c%y "$backup" 2>/dev/null | cut -d' ' -f1)
            local encrypted=""
            [[ "$backup" == *.enc ]] && encrypted=" ðŸ”’"
            
            echo "  $(basename "$backup") [$size] $date$encrypted"
        done
        echo ""
    done
}

# Cleanup old backups
cleanup_old_backups() {
    local category="$1"
    local keep_count
    
    case "$category" in
        daily) keep_count=$KEEP_DAILY ;;
        weekly) keep_count=$KEEP_WEEKLY ;;
        monthly) keep_count=$KEEP_MONTHLY ;;
        *) return ;;
    esac
    
    local dir="$BACKUP_DIR/$category"
    local count=$(ls "$dir"/*.enc "$dir"/*.gz 2>/dev/null | wc -l)
    
    if [[ $count -gt $keep_count ]]; then
        local to_delete=$((count - keep_count))
        info "Cleaning up $to_delete old backups in $category"
        
        ls -t "$dir"/*.enc "$dir"/*.gz 2>/dev/null | tail -n "$to_delete" | while read -r file; do
            rm -f "$file" "$file.sha256"
        done
    fi
}

# Quick backup of specific paths
quick_backup() {
    local paths="$@"
    [[ -z "$paths" ]] && error "Usage: quick <path1> [path2] ..."
    
    local name="quick-$(date +%H%M%S)"
    local backup_file="$BACKUP_DIR/manual/nullsec-$name.tar.gz"
    
    info "Quick backup: $paths"
    
    tar -czf "$backup_file" $paths 2>/dev/null
    
    local size=$(du -h "$backup_file" | cut -f1)
    log "Created: $backup_file ($size)"
}

# Scheduled backup
scheduled_backup() {
    local type="${1:-daily}"
    
    source "$CONFIG_FILE"
    create_backup "scheduled" "$type"
}

# Setup systemd timer
setup_scheduler() {
    info "Setting up backup scheduler..."
    
    mkdir -p "$HOME/.config/systemd/user"
    
    # Daily backup service
    cat > "$HOME/.config/systemd/user/nullsec-backup-daily.service" << EOF
[Unit]
Description=NullSec Daily Backup

[Service]
Type=oneshot
ExecStart=$HOME/.local/bin/nullsec-backup scheduled daily
EOF

    # Daily timer
    cat > "$HOME/.config/systemd/user/nullsec-backup-daily.timer" << EOF
[Unit]
Description=NullSec Daily Backup Timer

[Timer]
OnCalendar=*-*-* 02:00:00
Persistent=true

[Install]
WantedBy=timers.target
EOF

    # Weekly backup
    cat > "$HOME/.config/systemd/user/nullsec-backup-weekly.service" << EOF
[Unit]
Description=NullSec Weekly Backup

[Service]
Type=oneshot
ExecStart=$HOME/.local/bin/nullsec-backup scheduled weekly
EOF

    cat > "$HOME/.config/systemd/user/nullsec-backup-weekly.timer" << EOF
[Unit]
Description=NullSec Weekly Backup Timer

[Timer]
OnCalendar=Sun *-*-* 03:00:00
Persistent=true

[Install]
WantedBy=timers.target
EOF

    systemctl --user daemon-reload
    systemctl --user enable --now nullsec-backup-daily.timer 2>/dev/null || true
    systemctl --user enable --now nullsec-backup-weekly.timer 2>/dev/null || true
    
    log "Scheduler configured"
    info "Daily backup: 2:00 AM"
    info "Weekly backup: Sunday 3:00 AM"
}

show_help() {
    banner
    cat << 'HELP'
USAGE:
    nullsec-backup <command> [options]

BACKUP:
    create [name]       Create manual backup
    quick <paths>       Quick backup specific paths
    scheduled <type>    Run scheduled backup (daily/weekly/monthly)

RESTORE:
    restore <file>      Restore from backup
    list                List available backups

SCHEDULE:
    setup               Setup automatic backups

CONFIG:
    config              Edit backup configuration

EXAMPLES:
    nullsec-backup create mybackup
    nullsec-backup quick ~/.ssh ~/.gnupg
    nullsec-backup restore ~/backups/backup.tar.gz.enc
    nullsec-backup list
    nullsec-backup setup

CONFIG FILE:
    ~/.config/nullsec/backup.conf

LICENSE:
    NullSec Public License v1.0
HELP
}

main() {
    init
    case "${1:-help}" in
        create|backup) shift; create_backup "$@" ;;
        quick) shift; quick_backup "$@" ;;
        scheduled) shift; scheduled_backup "$@" ;;
        restore) shift; restore_backup "$@" ;;
        list|ls) list_backups ;;
        setup|schedule) setup_scheduler ;;
        config) ${EDITOR:-nano} "$CONFIG_FILE" ;;
        *) show_help ;;
    esac
}

main "$@"
