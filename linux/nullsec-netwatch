#!/usr/bin/env python3
"""
NullSec NetWatch - Network Traffic Monitor
==========================================
Real-time network monitoring with threat detection.

Features:
- Live connection tracking
- Suspicious activity detection
- GeoIP lookups
- Bandwidth monitoring
- Port scan detection
- DNS leak detection

(c) bad-antics development
"""

import os
import sys
import time
import socket
import struct
import signal
import argparse
import subprocess
import re
from collections import defaultdict
from datetime import datetime
from typing import Dict, List, Set, Tuple, Optional

# ============================================================================
# Colors
# ============================================================================

class C:
    RST = '\033[0m'
    BLD = '\033[1m'
    DIM = '\033[2m'
    RED = '\033[0;31m'
    GRN = '\033[0;32m'
    YLW = '\033[0;33m'
    BLU = '\033[0;34m'
    MAG = '\033[0;35m'
    CYN = '\033[0;36m'

# ============================================================================
# Known Threat Indicators
# ============================================================================

SUSPICIOUS_PORTS = {
    4444: "Metasploit default",
    5555: "Android ADB",
    6666: "IRC backdoor",
    6667: "IRC (often C2)",
    31337: "Back Orifice",
    12345: "NetBus",
    27374: "SubSeven",
    1337: "Common backdoor",
    8080: "Proxy/C2",
    9001: "Tor",
    9050: "Tor SOCKS",
    3389: "RDP",
    5900: "VNC",
    22: "SSH (monitor)",
    23: "Telnet (insecure)",
}

KNOWN_MALICIOUS_RANGES = [
    # Example ranges - would be updated with real threat intel
    "185.220.100.",  # Tor exit nodes
    "185.220.101.",
    "45.155.205.",   # Known bulletproof hosting
]

# ============================================================================
# Network Utilities
# ============================================================================

def get_connections() -> List[Dict]:
    """Get current network connections using ss command."""
    connections = []
    try:
        result = subprocess.run(
            ['ss', '-tunap'],
            capture_output=True,
            text=True
        )
        
        for line in result.stdout.strip().split('\n')[1:]:
            parts = line.split()
            if len(parts) >= 5:
                state = parts[0]
                local = parts[4]
                remote = parts[5] if len(parts) > 5 else '*:*'
                process = parts[-1] if 'users:' in line else ''
                
                # Parse process name
                proc_match = re.search(r'"([^"]+)"', process)
                proc_name = proc_match.group(1) if proc_match else 'unknown'
                
                connections.append({
                    'state': state,
                    'local': local,
                    'remote': remote,
                    'process': proc_name
                })
    except Exception:
        pass
    
    return connections


def get_bandwidth() -> Tuple[int, int]:
    """Get current bandwidth usage (rx, tx bytes)."""
    rx_bytes = 0
    tx_bytes = 0
    
    try:
        with open('/proc/net/dev', 'r') as f:
            for line in f:
                if ':' in line and 'lo:' not in line:
                    parts = line.split(':')[1].split()
                    rx_bytes += int(parts[0])
                    tx_bytes += int(parts[8])
    except Exception:
        pass
    
    return rx_bytes, tx_bytes


def resolve_hostname(ip: str) -> str:
    """Reverse DNS lookup."""
    try:
        hostname, _, _ = socket.gethostbyaddr(ip)
        return hostname[:30]
    except Exception:
        return ''


def check_dns_leak() -> List[str]:
    """Check for DNS leaks by querying DNS servers."""
    dns_servers = []
    try:
        with open('/etc/resolv.conf', 'r') as f:
            for line in f:
                if line.startswith('nameserver'):
                    dns_servers.append(line.split()[1])
    except Exception:
        pass
    return dns_servers


def get_listening_ports() -> List[Dict]:
    """Get all listening ports."""
    ports = []
    try:
        result = subprocess.run(
            ['ss', '-tlnp'],
            capture_output=True,
            text=True
        )
        
        for line in result.stdout.strip().split('\n')[1:]:
            parts = line.split()
            if len(parts) >= 4:
                local = parts[3]
                if ':' in local:
                    port = int(local.rsplit(':', 1)[1])
                    proc_match = re.search(r'"([^"]+)"', line)
                    proc = proc_match.group(1) if proc_match else 'unknown'
                    ports.append({'port': port, 'process': proc})
    except Exception:
        pass
    
    return ports


# ============================================================================
# Threat Detection
# ============================================================================

class ThreatDetector:
    """Detects suspicious network activity."""
    
    def __init__(self):
        self.connection_history: Dict[str, int] = defaultdict(int)
        self.port_scan_tracker: Dict[str, Set[int]] = defaultdict(set)
        self.alerts: List[Dict] = []
        self.last_check = time.time()
    
    def analyze_connection(self, conn: Dict) -> Optional[Dict]:
        """Analyze a connection for threats."""
        remote = conn.get('remote', '*:*')
        
        if remote == '*:*' or remote.startswith('127.') or remote.startswith('[::'):
            return None
        
        # Parse IP and port
        try:
            if ']:' in remote:  # IPv6
                ip, port = remote.rsplit(':', 1)
                ip = ip.strip('[]')
            else:
                ip, port = remote.rsplit(':', 1)
            port = int(port)
        except Exception:
            return None
        
        threat = None
        
        # Check suspicious ports
        if port in SUSPICIOUS_PORTS:
            threat = {
                'level': 'WARN',
                'type': 'Suspicious Port',
                'detail': f"{ip}:{port} - {SUSPICIOUS_PORTS[port]}",
                'ip': ip,
                'port': port
            }
        
        # Check known malicious ranges
        for range_prefix in KNOWN_MALICIOUS_RANGES:
            if ip.startswith(range_prefix):
                threat = {
                    'level': 'HIGH',
                    'type': 'Known Threat Range',
                    'detail': f"Connection to known malicious IP: {ip}",
                    'ip': ip,
                    'port': port
                }
                break
        
        # Port scan detection
        self.port_scan_tracker[ip].add(port)
        if len(self.port_scan_tracker[ip]) > 10:
            threat = {
                'level': 'HIGH',
                'type': 'Port Scan Detected',
                'detail': f"{ip} probed {len(self.port_scan_tracker[ip])} ports",
                'ip': ip,
                'port': port
            }
        
        # Connection frequency tracking
        self.connection_history[ip] += 1
        if self.connection_history[ip] > 100:
            threat = {
                'level': 'WARN',
                'type': 'High Connection Rate',
                'detail': f"{ip} - {self.connection_history[ip]} connections",
                'ip': ip,
                'port': port
            }
        
        if threat:
            self.alerts.append({**threat, 'time': datetime.now()})
        
        return threat
    
    def get_recent_alerts(self, count: int = 5) -> List[Dict]:
        """Get most recent alerts."""
        return self.alerts[-count:]
    
    def reset_trackers(self):
        """Reset periodic trackers."""
        now = time.time()
        if now - self.last_check > 60:
            self.port_scan_tracker.clear()
            self.connection_history.clear()
            self.last_check = now


# ============================================================================
# Display Functions
# ============================================================================

def clear_screen():
    """Clear terminal screen."""
    print('\033[2J\033[H', end='')


def format_bytes(b: int) -> str:
    """Format bytes to human readable."""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if b < 1024:
            return f"{b:.1f}{unit}"
        b /= 1024
    return f"{b:.1f}TB"


def print_banner():
    """Print application banner."""
    print(f"""
{C.CYN}  ╔═══════════════════════════════════════════════════════════╗
  ║                  NULLSEC NETWATCH                         ║
  ║              Network Traffic Monitor                      ║
  ╚═══════════════════════════════════════════════════════════╝{C.RST}
""")


def print_connections(connections: List[Dict], detector: ThreatDetector):
    """Display current connections."""
    print(f"  {C.BLD}Active Connections:{C.RST}")
    print(f"  {C.DIM}{'─' * 70}{C.RST}")
    
    established = [c for c in connections if c['state'] in ('ESTAB', 'ESTABLISHED')]
    
    if not established:
        print(f"  {C.DIM}No active connections{C.RST}")
        return
    
    for conn in established[:15]:
        remote = conn['remote']
        process = conn['process'][:15]
        
        # Check for threats
        threat = detector.analyze_connection(conn)
        
        if threat:
            if threat['level'] == 'HIGH':
                color = C.RED
                indicator = '⚠'
            else:
                color = C.YLW
                indicator = '!'
            print(f"  {color}{indicator} {remote:40} {process}{C.RST}")
        else:
            print(f"  {C.GRN}✓{C.RST} {remote:40} {C.DIM}{process}{C.RST}")
    
    if len(established) > 15:
        print(f"  {C.DIM}... and {len(established) - 15} more{C.RST}")


def print_alerts(detector: ThreatDetector):
    """Display recent alerts."""
    alerts = detector.get_recent_alerts()
    
    if not alerts:
        return
    
    print(f"\n  {C.BLD}Recent Alerts:{C.RST}")
    print(f"  {C.DIM}{'─' * 70}{C.RST}")
    
    for alert in alerts:
        if alert['level'] == 'HIGH':
            color = C.RED
        else:
            color = C.YLW
        
        time_str = alert['time'].strftime('%H:%M:%S')
        print(f"  {color}[{alert['level']}]{C.RST} {time_str} - {alert['type']}: {alert['detail']}")


def print_listening(ports: List[Dict]):
    """Display listening ports."""
    print(f"\n  {C.BLD}Listening Ports:{C.RST}")
    print(f"  {C.DIM}{'─' * 70}{C.RST}")
    
    for p in ports[:10]:
        port = p['port']
        proc = p['process']
        
        if port in SUSPICIOUS_PORTS:
            print(f"  {C.YLW}! {port:5} {proc:20} ({SUSPICIOUS_PORTS[port]}){C.RST}")
        else:
            print(f"  {C.GRN}✓{C.RST} {port:5} {C.DIM}{proc}{C.RST}")


def print_bandwidth(prev_rx: int, prev_tx: int, curr_rx: int, curr_tx: int, interval: float):
    """Display bandwidth usage."""
    rx_rate = (curr_rx - prev_rx) / interval
    tx_rate = (curr_tx - prev_tx) / interval
    
    print(f"\n  {C.BLD}Bandwidth:{C.RST}")
    print(f"  {C.DIM}{'─' * 70}{C.RST}")
    print(f"  {C.GRN}↓{C.RST} {format_bytes(rx_rate)}/s    {C.RED}↑{C.RST} {format_bytes(tx_rate)}/s    {C.DIM}Total: ↓{format_bytes(curr_rx)} ↑{format_bytes(curr_tx)}{C.RST}")


def print_dns(dns_servers: List[str]):
    """Display DNS configuration."""
    print(f"\n  {C.BLD}DNS Servers:{C.RST}")
    print(f"  {C.DIM}{'─' * 70}{C.RST}")
    
    for dns in dns_servers:
        # Check if it's a local/VPN DNS
        if dns.startswith('127.') or dns.startswith('10.') or dns.startswith('192.168.'):
            print(f"  {C.GRN}✓{C.RST} {dns} {C.DIM}(local/VPN){C.RST}")
        else:
            hostname = resolve_hostname(dns)
            print(f"  {C.YLW}!{C.RST} {dns} {C.DIM}{hostname}{C.RST}")


# ============================================================================
# Main Monitor Loop
# ============================================================================

def run_monitor(interval: float = 2.0, alerts_only: bool = False):
    """Run the network monitor."""
    detector = ThreatDetector()
    
    prev_rx, prev_tx = get_bandwidth()
    
    running = True
    
    def signal_handler(sig, frame):
        nonlocal running
        running = False
    
    signal.signal(signal.SIGINT, signal_handler)
    
    while running:
        try:
            clear_screen()
            print_banner()
            
            print(f"  {C.DIM}Monitoring... Press Ctrl+C to exit{C.RST}")
            print(f"  {C.DIM}Last update: {datetime.now().strftime('%H:%M:%S')}{C.RST}\n")
            
            # Get current data
            connections = get_connections()
            ports = get_listening_ports()
            curr_rx, curr_tx = get_bandwidth()
            dns_servers = check_dns_leak()
            
            if not alerts_only:
                # Display connections
                print_connections(connections, detector)
                
                # Display bandwidth
                print_bandwidth(prev_rx, prev_tx, curr_rx, curr_tx, interval)
                
                # Display listening ports
                print_listening(ports)
                
                # Display DNS
                print_dns(dns_servers)
            
            # Always display alerts
            print_alerts(detector)
            
            # Reset periodic trackers
            detector.reset_trackers()
            
            # Update previous bandwidth
            prev_rx, prev_tx = curr_rx, curr_tx
            
            time.sleep(interval)
            
        except Exception as e:
            print(f"  {C.RED}Error: {e}{C.RST}")
            time.sleep(1)
    
    print(f"\n  {C.DIM}Monitor stopped{C.RST}\n")


# ============================================================================
# CLI Entry Point
# ============================================================================

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='NullSec NetWatch - Network Traffic Monitor'
    )
    parser.add_argument('-i', '--interval', type=float, default=2.0,
                        help='Update interval in seconds (default: 2)')
    parser.add_argument('-a', '--alerts-only', action='store_true',
                        help='Show only alerts/threats')
    parser.add_argument('--check', action='store_true',
                        help='Single check and exit')
    
    args = parser.parse_args()
    
    if os.geteuid() != 0:
        print(f"\n  {C.YLW}[!] Running without root - some features limited{C.RST}")
        print(f"  {C.DIM}Run with sudo for full monitoring capabilities{C.RST}\n")
    
    if args.check:
        # Single check mode
        print_banner()
        connections = get_connections()
        detector = ThreatDetector()
        print_connections(connections, detector)
        print_alerts(detector)
    else:
        run_monitor(args.interval, args.alerts_only)


if __name__ == '__main__':
    main()
