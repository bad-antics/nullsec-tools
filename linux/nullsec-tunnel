#!/bin/bash
# ============================================================================
# NullSec Tunnel - Secure Tunneling Toolkit
# ============================================================================
# SSH tunneling, port forwarding, and proxy management
# Licensed under NullSec Public License v1.0
# ============================================================================

VERSION="1.0.0"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

TUNNEL_DIR="$HOME/.local/share/nullsec/tunnels"
TUNNEL_PID="$TUNNEL_DIR/pids"
mkdir -p "$TUNNEL_PID"

info() { echo -e "${CYAN}[*]${NC} $1"; }
success() { echo -e "${GREEN}[✓]${NC} $1"; }
warn() { echo -e "${YELLOW}[!]${NC} $1"; }
error() { echo -e "${RED}[✗]${NC} $1"; }

# Local port forward (access remote service locally)
local_forward() {
    local lport="$1"
    local rhost="$2"
    local rport="$3"
    local ssh_target="$4"
    local name="${5:-tunnel-$lport}"
    
    [[ -z "$lport" || -z "$rhost" || -z "$rport" || -z "$ssh_target" ]] && {
        error "Usage: local <local_port> <remote_host> <remote_port> <ssh_user@host> [name]"
        return 1
    }
    
    info "Creating local tunnel: localhost:$lport -> $rhost:$rport via $ssh_target"
    
    ssh -f -N -L "$lport:$rhost:$rport" "$ssh_target" && {
        echo "$!" > "$TUNNEL_PID/$name.pid"
        success "Tunnel '$name' active on localhost:$lport"
    }
}

# Remote port forward (expose local service remotely)
remote_forward() {
    local rport="$1"
    local lhost="$2"
    local lport="$3"
    local ssh_target="$4"
    local name="${5:-reverse-$rport}"
    
    [[ -z "$rport" || -z "$lhost" || -z "$lport" || -z "$ssh_target" ]] && {
        error "Usage: remote <remote_port> <local_host> <local_port> <ssh_user@host> [name]"
        return 1
    }
    
    info "Creating remote tunnel: $ssh_target:$rport -> $lhost:$lport"
    
    ssh -f -N -R "$rport:$lhost:$lport" "$ssh_target" && {
        echo "$!" > "$TUNNEL_PID/$name.pid"
        success "Remote tunnel '$name' active on $ssh_target:$rport"
    }
}

# Dynamic SOCKS proxy
socks_proxy() {
    local port="${1:-1080}"
    local ssh_target="$2"
    local name="${3:-socks-$port}"
    
    [[ -z "$ssh_target" ]] && {
        error "Usage: socks <port> <ssh_user@host> [name]"
        return 1
    }
    
    info "Creating SOCKS5 proxy on localhost:$port via $ssh_target"
    
    ssh -f -N -D "$port" "$ssh_target" && {
        pgrep -f "ssh.*-D $port" > "$TUNNEL_PID/$name.pid"
        success "SOCKS5 proxy active on localhost:$port"
        echo ""
        echo "  Configure browser: SOCKS5 localhost:$port"
        echo "  Use with curl: curl --socks5 localhost:$port http://example.com"
        echo "  Use with proxychains: edit /etc/proxychains.conf"
    }
}

# Double hop tunnel
double_hop() {
    local lport="$1"
    local jump1="$2"
    local jump2="$3"
    local target="$4"
    local tport="$5"
    
    [[ -z "$lport" || -z "$jump1" || -z "$jump2" || -z "$target" || -z "$tport" ]] && {
        error "Usage: double <local_port> <jump1> <jump2> <target> <target_port>"
        return 1
    }
    
    info "Creating double-hop tunnel..."
    info "Path: localhost:$lport -> $jump1 -> $jump2 -> $target:$tport"
    
    ssh -f -N -L "$lport:localhost:$((lport+1000))" "$jump1" -o "ProxyCommand ssh -W %h:%p $jump2" && {
        success "Double-hop tunnel established"
    }
}

# ProxyJump tunnel
proxy_jump() {
    local lport="$1"
    local jump="$2"
    local target="$3"
    local tport="$4"
    local name="${5:-jump-$lport}"
    
    [[ -z "$lport" || -z "$jump" || -z "$target" || -z "$tport" ]] && {
        error "Usage: jump <local_port> <jump_host> <target> <target_port> [name]"
        return 1
    }
    
    info "Creating ProxyJump tunnel via $jump"
    
    ssh -f -N -L "$lport:$target:$tport" -J "$jump" "$target" && {
        pgrep -f "ssh.*-J $jump" > "$TUNNEL_PID/$name.pid"
        success "ProxyJump tunnel active on localhost:$lport"
    }
}

# Reverse shell listener wrapper
listener() {
    local port="${1:-4444}"
    local type="${2:-nc}"
    
    info "Starting listener on port $port..."
    
    case "$type" in
        nc|netcat)
            echo "  Using: netcat"
            nc -lvnp "$port"
            ;;
        socat)
            echo "  Using: socat"
            socat TCP-LISTEN:"$port",reuseaddr,fork -
            ;;
        ssl)
            echo "  Using: socat with SSL"
            socat OPENSSL-LISTEN:"$port",cert=/tmp/server.pem,verify=0,reuseaddr,fork -
            ;;
        *)
            nc -lvnp "$port"
            ;;
    esac
}

# Create chisel tunnel (if installed)
chisel_tunnel() {
    local mode="$1"
    local args="${@:2}"
    
    if ! command -v chisel &>/dev/null; then
        error "Chisel not installed"
        echo "  Download: https://github.com/jpillora/chisel"
        return 1
    fi
    
    case "$mode" in
        server)
            local port="${2:-8080}"
            info "Starting Chisel server on port $port..."
            chisel server -p "$port" --reverse
            ;;
        client)
            local server="$2"
            local forward="$3"
            [[ -z "$server" || -z "$forward" ]] && {
                error "Usage: chisel client <server:port> <R:port:host:port>"
                return 1
            }
            info "Connecting to Chisel server $server..."
            chisel client "$server" "$forward"
            ;;
        *)
            error "Usage: chisel <server|client> [options]"
            ;;
    esac
}

# List active tunnels
list_tunnels() {
    echo -e "\n${CYAN}Active Tunnels:${NC}\n"
    
    # SSH tunnels
    ps aux | grep -E "ssh.*-[LRND]" | grep -v grep | while read -r line; do
        echo "  $line"
    done
    
    # Show saved PIDs
    echo ""
    for pidfile in "$TUNNEL_PID"/*.pid; do
        [[ -f "$pidfile" ]] || continue
        local name=$(basename "$pidfile" .pid)
        local pid=$(cat "$pidfile")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  ${GREEN}●${NC} $name (PID: $pid)"
        else
            echo -e "  ${RED}●${NC} $name (dead)"
            rm -f "$pidfile"
        fi
    done
}

# Kill tunnel
kill_tunnel() {
    local name="$1"
    
    if [[ -z "$name" ]]; then
        error "Tunnel name required"
        return 1
    fi
    
    local pidfile="$TUNNEL_PID/$name.pid"
    if [[ -f "$pidfile" ]]; then
        local pid=$(cat "$pidfile")
        kill "$pid" 2>/dev/null && {
            success "Killed tunnel '$name'"
            rm -f "$pidfile"
        }
    else
        error "Tunnel '$name' not found"
    fi
}

# Kill all tunnels
kill_all() {
    info "Killing all SSH tunnels..."
    pkill -f "ssh.*-[LRND]"
    rm -f "$TUNNEL_PID"/*.pid
    success "All tunnels terminated"
}

# Generate SSH config entry
gen_config() {
    local name="$1"
    local host="$2"
    local user="$3"
    local port="${4:-22}"
    local key="$5"
    
    [[ -z "$name" || -z "$host" || -z "$user" ]] && {
        error "Usage: config <name> <host> <user> [port] [keyfile]"
        return 1
    }
    
    cat << EOF

# Add to ~/.ssh/config:
Host $name
    HostName $host
    User $user
    Port $port
EOF
    [[ -n "$key" ]] && echo "    IdentityFile $key"
    echo "    ServerAliveInterval 60"
    echo "    ServerAliveCountMax 3"
}

show_help() {
    cat << 'HELP'
NullSec Tunnel - Secure Tunneling Toolkit

USAGE:
    nullsec-tunnel <command> [options]

COMMANDS:
    local <lport> <rhost> <rport> <ssh>   Local port forward
    remote <rport> <lhost> <lport> <ssh>  Remote port forward
    socks <port> <ssh_target>             SOCKS5 dynamic proxy
    jump <lport> <jump> <target> <tport>  ProxyJump tunnel
    double <lport> <j1> <j2> <tgt> <tp>   Double-hop tunnel
    listener <port> [nc|socat|ssl]        Start reverse listener
    chisel <server|client> [opts]         Chisel tunnel wrapper
    list                                   List active tunnels
    kill <name>                            Kill named tunnel
    killall                                Kill all tunnels
    config <name> <host> <user>            Generate SSH config

EXAMPLES:
    # Access remote MySQL locally
    nullsec-tunnel local 3306 10.10.10.1 3306 user@jump.host

    # Expose local web server remotely
    nullsec-tunnel remote 8080 localhost 80 user@remote.host

    # Create SOCKS proxy
    nullsec-tunnel socks 1080 user@proxy.host

    # ProxyJump through bastion
    nullsec-tunnel jump 22 bastion internal 22

    # Start reverse shell listener
    nullsec-tunnel listener 4444

LICENSE:
    NullSec Public License v1.0
HELP
}

case "$1" in
    -h|--help|help|"") show_help ;;
    local|lf|-L) shift; local_forward "$@" ;;
    remote|rf|-R) shift; remote_forward "$@" ;;
    socks|dynamic|-D) shift; socks_proxy "$@" ;;
    jump|proxy) shift; proxy_jump "$@" ;;
    double|multihop) shift; double_hop "$@" ;;
    listener|listen|nc) shift; listener "$@" ;;
    chisel) shift; chisel_tunnel "$@" ;;
    list|ls|status) list_tunnels ;;
    kill|stop) shift; kill_tunnel "$@" ;;
    killall|stopall) kill_all ;;
    config|gen) shift; gen_config "$@" ;;
    *) error "Unknown: $1"; show_help; exit 1 ;;
esac
